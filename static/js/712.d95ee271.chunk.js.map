{"version":3,"file":"static/js/712.d95ee271.chunk.js","mappings":"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","sources":["../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/isScrollable.ts","../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useEvent.ts","../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/getScrollParents.ts","../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/scrollIntoView.ts","../node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useSelectableCollection.ts","../node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/utils.ts","../node_modules/@react-stately/collections/dist/packages/@react-stately/collections/src/Item.ts","../node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useTypeSelect.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function isScrollable(node: Element | null, checkForOverflow?: boolean): boolean {\n  if (!node) {\n    return false;\n  }\n  let style = window.getComputedStyle(node);\n  let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n\n  if (isScrollable && checkForOverflow) {\n    isScrollable = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;\n  }\n\n  return isScrollable;\n}\n","/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RefObject} from '@react-types/shared';\nimport {useEffect} from 'react';\nimport {useEffectEvent} from './useEffectEvent';\n\nexport function useEvent<K extends keyof GlobalEventHandlersEventMap>(\n  ref: RefObject<EventTarget | null>,\n  event: K | (string & {}),\n  handler?: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let handleEvent = useEffectEvent(handler);\n  let isDisabled = handler == null;\n\n  useEffect(() => {\n    if (isDisabled || !ref.current) {\n      return;\n    }\n\n    let element = ref.current;\n    element.addEventListener(event, handleEvent as EventListener, options);\n    return () => {\n      element.removeEventListener(event, handleEvent as EventListener, options);\n    };\n  }, [ref, event, options, isDisabled, handleEvent]);\n}\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isScrollable} from './isScrollable';\n\nexport function getScrollParents(node: Element, checkForOverflow?: boolean): Element[] {\n  const scrollParents: Element[] = [];\n\n  while (node && node !== document.documentElement) {\n    if (isScrollable(node, checkForOverflow)) {\n      scrollParents.push(node);\n    }\n    node = node.parentElement as Element;\n  }\n\n  return scrollParents;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getScrollParents} from './getScrollParents';\n\ninterface ScrollIntoViewportOpts {\n  /** The optional containing element of the target to be centered in the viewport. */\n  containingElement?: Element | null\n}\n\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nexport function scrollIntoView(scrollView: HTMLElement, element: HTMLElement) {\n  let offsetX = relativeOffset(scrollView, element, 'left');\n  let offsetY = relativeOffset(scrollView, element, 'top');\n  let width = element.offsetWidth;\n  let height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n\n  // Account for top/left border offsetting the scroll top/Left\n  let {borderTopWidth, borderLeftWidth} = getComputedStyle(scrollView);\n  let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n  let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n  // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n  let maxX = borderAdjustedX + scrollView.clientWidth;\n  let maxY = borderAdjustedY + scrollView.clientHeight;\n\n  if (offsetX <= x) {\n    x = offsetX - parseInt(borderLeftWidth, 10);\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= borderAdjustedY) {\n    y = offsetY - parseInt(borderTopWidth, 10);\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\n\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */\nfunction relativeOffset(ancestor: HTMLElement, child: HTMLElement, axis: 'left'|'top') {\n  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';\n  let sum = 0;\n  while (child.offsetParent) {\n    sum += child[prop];\n    if (child.offsetParent === ancestor) {\n      // Stop once we have found the ancestor we are interested in.\n      break;\n    } else if (child.offsetParent.contains(ancestor)) {\n      // If the ancestor is not `position:relative`, then we stop at\n      // _its_ offset parent, and we subtract off _its_ offset, so that\n      // we end up with the proper offset from child to ancestor.\n      sum -= ancestor[prop];\n      break;\n    }\n    child = child.offsetParent as HTMLElement;\n  }\n  return sum;\n}\n\n/**\n * Scrolls the `targetElement` so it is visible in the viewport. Accepts an optional `opts.containingElement`\n * that will be centered in the viewport prior to scrolling the targetElement into view. If scrolling is prevented on\n * the body (e.g. targetElement is in a popover), this will only scroll the scroll parents of the targetElement up to but not including the body itself.\n */\nexport function scrollIntoViewport(targetElement: Element | null, opts?: ScrollIntoViewportOpts) {\n  if (targetElement && document.contains(targetElement)) {\n    let root = document.scrollingElement || document.documentElement;\n    let isScrollPrevented = window.getComputedStyle(root).overflow === 'hidden';\n    // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n    if (!isScrollPrevented) {\n      let {left: originalLeft, top: originalTop} = targetElement.getBoundingClientRect();\n\n      // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()\n      // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n      targetElement?.scrollIntoView?.({block: 'nearest'});\n      let {left: newLeft, top: newTop} = targetElement.getBoundingClientRect();\n      // Account for sub pixel differences from rounding\n      if ((Math.abs(originalLeft - newLeft) > 1) || (Math.abs(originalTop - newTop) > 1)) {\n        opts?.containingElement?.scrollIntoView?.({block: 'center', inline: 'center'});\n        targetElement.scrollIntoView?.({block: 'nearest'});\n      }\n    } else {\n      let scrollParents = getScrollParents(targetElement);\n      // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n      for (let scrollParent of scrollParents) {\n        scrollIntoView(scrollParent as HTMLElement, targetElement as HTMLElement);\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, FocusStrategy, Key, KeyboardDelegate, RefObject} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {FocusEvent, KeyboardEvent, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, scrollIntoViewport, useEvent, useRouter} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement | null>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement | null>,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override'\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = 'action'\n  } = options;\n  let {direction} = useLocale();\n  let router = useRouter();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current?.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          flushSync(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n\n          let item = scrollRef.current?.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n          let itemProps = manager.getItemProps(key);\n          if (item) {\n            router.open(item, e, itemProps.href, itemProps.routerOptions);\n          }\n\n          return;\n        }\n\n        manager.setFocusedKey(key, childFocus);\n\n        if (manager.isLink(key) && linkBehavior === 'override') {\n          return;\n        }\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow?.(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove?.(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          let nextKey: Key | undefined | null = manager.focusedKey != null ? delegate.getKeyLeftOf?.(manager.focusedKey) : null;\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getFirstKey?.(manager.focusedKey) : delegate.getLastKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          let nextKey: Key | undefined | null = manager.focusedKey != null ? delegate.getKeyRightOf?.(manager.focusedKey) : null;\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getLastKey?.(manager.focusedKey) : delegate.getFirstKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n          }\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey: Key | null = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (firstKey != null) {\n            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(firstKey);\n            } else if (selectOnFocus) {\n              manager.replaceSelection(firstKey);\n            }\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (lastKey != null) {\n            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(lastKey);\n            } else if (selectOnFocus) {\n              manager.replaceSelection(lastKey);\n            }\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow && manager.focusedKey != null) {\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove && manager.focusedKey != null) {\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {\n          e.stopPropagation();\n          e.preventDefault();\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement | undefined = undefined;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  /// TODO: should this happen all the time??\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? undefined : () => {\n    scrollPos.current = {\n      top: scrollRef.current?.scrollTop ?? 0,\n      left: scrollRef.current?.scrollLeft ?? 0\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined | null) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey?.());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey?.());\n      }\n    } else if (!isVirtualized && scrollRef.current) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n\n    if (manager.focusedKey != null && scrollRef.current) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) {\n          focusWithoutScrolling(element);\n        }\n\n        let modality = getInteractionModality();\n        if (modality === 'keyboard') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey: Key | null = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey?.() ?? null;\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey?.() ?? null;\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (let key of selectedKeys) {\n          if (manager.canSelectItem(key)) {\n            focusedKey = key;\n            break;\n          }\n        }\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus && ref.current) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Scroll the focused element into view when the focusedKey changes.\n  let lastFocusedKey = useRef(manager.focusedKey);\n  useEffect(() => {\n    if (manager.isFocused && manager.focusedKey != null && (manager.focusedKey !== lastFocusedKey.current || autoFocusRef.current) && scrollRef.current && ref.current) {\n      let modality = getInteractionModality();\n      let element = ref.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`) as HTMLElement;\n      if (!element) {\n        // If item element wasn't found, return early (don't update autoFocusRef and lastFocusedKey).\n        // The collection may initially be empty (e.g. virtualizer), so wait until the element exists.\n        return;\n      }\n\n      if (modality === 'keyboard' || autoFocusRef.current) {\n        scrollIntoView(scrollRef.current, element);\n\n        // Avoid scroll in iOS VO, since it may cause overlay to close (i.e. RAC submenu)\n        if (modality !== 'virtual') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (!shouldUseVirtualFocus && manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null && ref.current) {\n      focusSafely(ref.current);\n    }\n\n    lastFocusedKey.current = manager.focusedKey;\n    autoFocusRef.current = false;\n  });\n\n  // Intercept FocusScope restoration since virtualized collections can reuse DOM nodes.\n  useEvent(ref, 'react-aria-focus-scope-restore', e => {\n    e.preventDefault();\n    manager.setFocused(true);\n  });\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number | undefined = undefined;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice, isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ItemElement, ItemProps} from '@react-types/shared';\nimport {PartialNode} from './types';\nimport React, {JSX, ReactElement} from 'react';\n\nfunction Item<T>(props: ItemProps<T>): ReactElement | null { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nItem.getCollectionNode = function* getCollectionNode<T>(props: ItemProps<T>, context: any): Generator<PartialNode<T>> {\n  let {childItems, title, children} = props;\n\n  let rendered = props.title || props.children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || '';\n\n  // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n  if (!textValue && !context?.suppressTextValueWarning) {\n    console.warn('<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.');\n  }\n\n  yield {\n    type: 'item',\n    props: props,\n    rendered,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: hasChildItems(props),\n    *childNodes() {\n      if (childItems) {\n        for (let child of childItems) {\n          yield {\n            type: 'item',\n            value: child\n          };\n        }\n      } else if (title) {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          items.push({\n            type: 'item',\n            element: child as ItemElement<T>\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\nfunction hasChildItems<T>(props: ItemProps<T>) {\n  if (props.hasChildItems != null) {\n    return props.hasChildItems;\n  }\n\n  if (props.childItems) {\n    return true;\n  }\n\n  if (props.title && React.Children.count(props.children) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// We don't want getCollectionNode to show up in the type definition\nlet _Item = Item as <T>(props: ItemProps<T>) => JSX.Element;\nexport {_Item as Item};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, Key, KeyboardDelegate} from '@react-types/shared';\nimport {KeyboardEvent, useRef} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nexport interface AriaTypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\nexport interface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: DOMAttributes\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: AriaTypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef<{search: string, timeout: ReturnType<typeof setTimeout> | undefined}>({\n    search: '',\n    timeout: undefined\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    if (keyboardDelegate.getKeyForSearch != null) {\n      // Use the delegate to find a key to focus.\n      // Prioritize items after the currently focused item, falling back to searching the whole list.\n      let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n      // If no key found, search from the top.\n      if (key == null) {\n        key = keyboardDelegate.getKeyForSearch(state.search);\n      }\n\n      if (key != null) {\n        selectionManager.setFocusedKey(key);\n        if (onTypeSelect) {\n          onTypeSelect(key);\n        }\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : undefined\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n"],"names":["$cc38e7bd3fc7b213$export$2bb74740c4e19def","node","checkForOverflow","style","window","getComputedStyle","isScrollable","test","overflow","overflowX","overflowY","scrollHeight","clientHeight","scrollWidth","clientWidth","$e9faafb641e167db$export$90fc3a17d93f704c","ref","event","handler","options","handleEvent","$8ae05eaa5c114e9c$export$7f54fc3180508a52","isDisabled","$ceQd6$useEffect","current","element","addEventListener","removeEventListener","$a40c673dc9f6d9c7$export$94ed1c92c7beeb22","scrollParents","document","documentElement","push","parentElement","$2f04cbc44ee30ce0$export$53a0910f038337bd","scrollView","offsetX","$2f04cbc44ee30ce0$var$relativeOffset","offsetY","width","offsetWidth","height","offsetHeight","x","scrollLeft","y","scrollTop","borderTopWidth","borderLeftWidth","borderAdjustedX","parseInt","borderAdjustedY","maxX","maxY","ancestor","child","axis","prop","sum","offsetParent","contains","$2f04cbc44ee30ce0$export$c826860796309d1b","targetElement","opts","root","scrollingElement","scrollParent","_targetElement_scrollIntoView","left","originalLeft","top","originalTop","getBoundingClientRect","scrollIntoView","call","block","newLeft","newTop","_opts_containingElement_scrollIntoView","_opts_containingElement","_targetElement_scrollIntoView1","Math","abs","containingElement","inline","$ae20dd8cbca75726$export$d6daf82dcd84e87c","selectionManager","manager","keyboardDelegate","delegate","autoFocus","shouldFocusWrap","disallowEmptySelection","disallowSelectAll","selectOnFocus","selectionBehavior","disallowTypeAhead","shouldUseVirtualFocus","allowsTabNavigation","isVirtualized","scrollRef","linkBehavior","direction","$3H3GQ$useLocale","router","$3H3GQ$useRouter","scrollPos","$3H3GQ$useRef","$3H3GQ$useEvent","undefined","_scrollRef_current","_scrollRef_current1","_scrollRef_current_scrollTop","_scrollRef_current_scrollLeft","autoFocusRef","$3H3GQ$useEffect","_delegate_getFirstKey","_delegate_getLastKey","focusedKey","_delegate_getFirstKey1","_delegate_getLastKey1","getFirstKey","getLastKey","selectedKeys","size","key","canSelectItem","setFocused","setFocusedKey","$3H3GQ$focusSafely","lastFocusedKey","isFocused","modality","$3H3GQ$getInteractionModality","querySelector","concat","CSS","escape","toString","$3H3GQ$scrollIntoView","$3H3GQ$scrollIntoViewport","e","preventDefault","tabIndex","handlers","_ref_current","altKey","target","navigateToKey","childFocus","isLink","$feb5ffebff200149$export$d3e3bd3e26688c04","$3H3GQ$flushSync","item","itemProps","getItemProps","open","href","routerOptions","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","_delegate_getKeyBelow","nextKey","getKeyAbove","_delegate_getKeyAbove","getKeyLeftOf","_delegate_getKeyLeftOf","_delegate_getFirstKey2","_delegate_getLastKey2","getKeyRightOf","_delegate_getKeyRightOf","_delegate_getLastKey3","_delegate_getFirstKey3","firstKey","$feb5ffebff200149$export$16792effe837dba3","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","stopPropagation","clearSelection","focus","next","last","walker","$3H3GQ$getFocusableTreeWalker","tabbable","lastChild","activeElement","$3H3GQ$focusWithoutScrolling","currentTarget","navigateToFirstKey","relatedTarget","_manager_lastSelectedKey","_manager_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","onMouseDown","typeSelectProps","$fb3050f43d946246$export$e32c88dfddc6e1d8","$3H3GQ$mergeProps","collectionProps","_objectSpread","$jUnAJ$isAppleDevice","ctrlKey","$jUnAJ$isMac","metaKey","$c1d7fb2ec91bae71$var$Item","props","$c1d7fb2ec91bae71$var$hasChildItems","hasChildItems","childItems","title","$6Fm0V$react","Children","count","children","getCollectionNode","context","rendered","textValue","suppressTextValueWarning","console","warn","type","hasChildNodes","childNodes","value","items","forEach","$c1d7fb2ec91bae71$export$6d08773d2e66f8f2","$fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS","onTypeSelect","state","$dAE4Y$useRef","search","timeout","onKeyDownCapture","getKeyForSearch","character","length","trim","clearTimeout","setTimeout"],"sourceRoot":""}